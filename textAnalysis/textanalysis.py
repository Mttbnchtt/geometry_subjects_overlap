# -*- coding: utf-8 -*-
"""
TextAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h7-oRg1hS76m65rBcw7WI7i6NmrAkGHr


_ Mar 2021
_ author: Matteo Bianchetti
_ Python version: ≥ 3.7
_ version 1


    Input: txt files divided by category in different folders
           each file contians the index of a book, mostly math but also other
           sciences
    Output: percentage of how many words each file in a category are also in
            files of another category average percentages by category
"""

"------------------------------------------------------------------------------"
" MODULES "
import glob
from google.colab import drive
import math
import pandas as pd
import re
import string

"------------------------------------------------------------------------------"

" FUNCTIONS "

" COMPARING FUNCTIONS "
def compare_txt(set1,
                set2
               ):
    """
        compare two sets of words
        return the ratio R of common words over the the length of the second set
        return also the rounded R
        (which is the floor of R if R is equally close to two integers,
        e.g the rounded 0.5 is 0)
    """
    common = set1.intersection(set2)
    ratio = 100 * len(common) / len(set2)
    return ratio, round(ratio)

def compare_dct_txt(dct_categories,
                    special_categories=set()
                   ):
    """
        Compare files in distinct categories
        Measure the percentage of common words
    """
    # check whether there are at least two categories to compare
    # return error if not
    if len(dct_categories) < 2:
        print("InputError: need at least two categories to compare.")
        df = pd.DataFrame()
    # compare categories if there are at least two categories
    else:
        # dictionary to receive data from comparisons of files
        dct_comparison_files = {
                                "comparison" : [],
                                "rounded" : [],
                                "ratio" : []
                               }
        # special categories are those whose txt files one wants to check against other categories
        # but not the other way round,
        # i.e. one checks the percentage of words in a special category txt file in the file in another category
        # but does not check the percentage of words in the other category that appear in the special category file
        dct_combinations = {
                    category : [k for k in dct_categories if not (k in special_categories or category == k)]
                    for category in dct_categories
                    }
                # dictionary to receive data from comparison of categories
        dct_comparison_categories = {category:{k:"" for k in dct_combinations[category]} for category in dct_categories}
        # compare the sets of words
        # for each category, select a file and, for each other category, select a file
        # compare the sets of words in the two files
        # attach the ratio and the rounded ratio to dct_comparison_files
        # attach the rounded ratio of the categories comparison to dct_comparison_categories
        for category in dct_categories:
            # print(category)
            set_data = set()
            for other_category in dct_combinations[category]:
                for category_file in dct_categories[category]:
                    category_set = dct_categories[category][category_file]
                    for other_file in dct_categories[other_category]:
                        other_set = dct_categories[other_category][other_file]
                        ratio, rounded = compare_txt(category_set, other_set) #ratio and rounded ratio set-set
                        dct_comparison_files["comparison"].append(f"{category_file}-{other_file}")
                        dct_comparison_files["rounded"].append(rounded)
                        dct_comparison_files["ratio"].append(ratio)
                        set_data.add(ratio)
                ratio_cat_cat = round(sum(set_data) / len(set_data)) #rounded ratio cat-cat
                dct_comparison_categories[category][other_category] = ratio_cat_cat
    return dct_comparison_files, dct_comparison_categories

" EDITING FUNCTIONS"
def dict_to_df(dct
               ):
    list_columns = sorted([column for column in dct])
    list_index = sorted(list({index for column in dct for index in dct[column]}))
    df = pd.DataFrame(columns=list_columns, index=list_index)
    for column_name in list_columns:
        for index_name in list_index:
            if not column_name == index_name:
                df.at[index_name, column_name] = dct[column_name][index_name]
    return df

def normalformstr(s,
                 remove_digits=True,
                 remove_punctuation=True,
                 remove_blanks=True,
                 remove_special=True,
                 remove_short=True
                ):
    """
        strip and lower case string
        optional: remove blanks
        optional: remove digits
        optional: remove punctuation
    """
    s = s.strip().lower()
    if remove_blanks == True:
        s = s.replace(" ", "")
    if remove_punctuation == True:
        s = s.translate(s.maketrans("", "", string.digits))
    if remove_punctuation == True:
        s = s.translate(s.maketrans("", "", string.punctuation))
    if remove_special == True:
        special = "`¡™£¢∞§¶•ªº«…≤≥÷µ¬˜∫√≈Ωåß∂©˙∆˚¬øˆ¨¥†´∑æøœ"
        s = s.translate(s.maketrans("", "", special))
    if remove_short == True:
        s = "" if len(s) == 1 else s
    return s

" FUNCTIONS ON FILES "
def file_folder(f_name):
    """
        find folder containing given file
    """
    file_name_short = f"/{file_name(f_name)}"
    if f_name.endswith(file_name_short):
        list_folder = re.findall(f".*/(.*){file_name_short}", f_name)
    else:
        list_folder = re.findall(".*/(.*)/", f_name)
    file_folder = list_folder[0] if not (list_folder == [] or list_folder == [""]) else f_name
    return file_folder

def file_glob(path=[],
              extension=[]
             ):
    """
        create a dictionary of lists of files
        according to paths and extensions
    """
    dct = {}
    for p in path:
        # dct[p] = []
        for e in extension:
            dct[p] = glob.glob(f"{p}*{e}")
    return dct

def file_name(f_name):
    """
        find file name of file
        (i.e. remove the path)
        remove extension
    """
    list_name = re.findall(".*/(.*)[.].*", f_name)
    file_name_short = list_name[0] if not list_name == [] else f_name
    return file_name_short

def file_path(f_name):
    """
        find path of file
    """
    list_path = re.findall("(.*/).*", f_name)
    file_path = list_path[0] if not list_path == [] else f_name
    return file_path

def file_name_path(f_name):
    """
        find name and path of file
    """
    return file_name(f_name), file_path(f_name)

" TRANSFORMING TYPES"
def folder_to_dct(dct,
                  write=True
                 ):
    dct_files= {}
    dct_files = {
            file_folder(folder): {
                file_name(f): txt_to_set_words(f, write_file=write)
                for f in dct[folder]
                }
            for folder in dct
        }
    return dct_files

def txt_to_set_words(file_txt,
                     write_file=False,
                     path=""
                     ):
    """
        open a txt file
        read it line by line
        split lines into words
        add words to a set
        add the set to a dictionary
        optional: write file with x option (exception if file exists)
    """
    if file_txt.endswith(".txt"):
        filename = file_txt.replace(".txt", "")
        with open(file_txt) as f:
            set_words = {
                normalformstr(word) for line in f for word in line.split()
                if not normalformstr(word) == ""
                }
            if write_file == True:
                try:
                    f_short, f_path = file_name_path(file_txt)
                    f_name = f"{f_path}cleaned/{f_short}Cleaned.txt"
                    with open(f_name, "x") as f2:
                        for word in set_words:
                            f2.write(f"{word}\n")
                except:
                    print(f"Cleaned version of {filename} already exist. Will not overwrite.")
        return set_words
    else:
        print(f"ExtensionError: {file_txt} must be a txt file.")
        return set()

"------------------------------------------------------------------------------"
" MAIN FUNCTION"

def main():

    " LIST FILES "
    path = f"otherTexts/"
    list_path = [
                 f"geometryTexts/",
                 f"{path}algebra/",
                 f"{path}analysis.calculus/",
                 f"{path}logic/",
                 f"{path}numberTheory/",
                 f"{path}combinatorics.probability/",
                 f"{path}physics/",
                 f"{path}mathematicalBiology/"
                ]
    list_extension = [".txt"]
    dct_files = file_glob(path=list_path, extension=list_extension)

    " DCT WITH WORDS LISTED BY FILE AND CATEGORY "
    dct_txt = folder_to_dct(dct_files, write=False)

    " COMPARE FILES AND CATEGORIES "
    dct_comparison_files, dct_comparison_categories = compare_dct_txt(dct_txt, special_categories={"geometryTexts"})

    " PREPARE OUTPUT "
    df_categories = dict_to_df(dct_comparison_categories)
    df_files = pd.DataFrame(dct_comparison_files)
    filename_output = "output/comparison"
    df_categories.to_csv(f"{filename_output}Categories.csv")
    df_files.to_csv(f"{filename_output}Files.csv")

"------------------------------------------------------------------------------"
" TASK "
if __name__ == "__main__":
    main()
